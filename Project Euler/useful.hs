
module Useful
(
    primes,
    isOddPrime,
    isPrime,
    isPermutation,
    factorial,
    binCoeff,
    equivalenceClasses
) where

import Data.List ((\\), partition)

-- all prime numbers generated by a recursive sieve of erathosthenes
primes :: [Int]
primes = sieve [2..]
    where sieve (p:ns) = p : sieve [n | n<-ns, n `mod` p /= 0]

-- pretty naive prime check for odd numbers. (ONLY FOR ODD NUMBERS!)
isOddPrime :: Int -> Bool
isOddPrime n = null $ filter (\k -> n `mod` k == 0) [3, 5.. limit]
    where limit = ceiling $ sqrt $ fromIntegral n

-- simple prime check in O(sqrt(n))
isPrime :: Int -> Bool
isPrime n = (n >= 2) && (n `mod` 2 /= 0 || n == 2) && (isOddPrime n) 

-- returns whether one string is a permutation of the other
isPermutation :: String -> String -> Bool
isPermutation s1 s2 = length s1 == length s2 && null (s1 \\ s2)

-- For a given natural number n >= 0, returns n!
factorial :: Integer -> Integer
factorial n | n > 0 = n * factorial (n-1)
            | otherwise = 1

-- For a natural number n >= 0 and 0 <= k <= n, returns the binomial coefficient n over k
-- WATCH OUT: binCoeff n k = 0 for n,k âˆˆ {0, 1}
binCoeff :: Integer -> Integer -> Integer
binCoeff n k = fact n `div` factorial (n - k)
    where fact n    | n > k = n * fact (n-1)
                    | otherwise = 1


-- helper method for equivalence classes
splitOffFirstGroup :: (a -> a -> Bool) -> [a] -> ([a],[a])
splitOffFirstGroup equal xs@(x:_) = partition (equal x) xs
splitOffFirstGroup _     []       = ([],[])

-- find equivalence classes for a given equivalence relation <equal> on a list/set <xs>
equivalenceClasses _     [] = []
equivalenceClasses equal xs = let (fg,rst) = splitOffFirstGroup equal xs
                              in fg : equivalenceClasses equal rst

